package {	import flash.events.Event;	import flash.events.KeyboardEvent;	import flash.geom.Point;	import flash.geom.Rectangle;	import flash.display.Sprite;	public class Hero extends Entity	{		var SCALE:Number = 1;				var hook:GrappleHook;				var isLatch:Boolean = false;		var isCrouch:Boolean = false;		//Collsion Detections		var RightBump:Boolean = false;		var LeftBump:Boolean = false;		var UpBump:Boolean = false;		var DownBump:Boolean = false;		var canLatch:Boolean = false;				var RightBumpPoint:Point;		var LeftBumpPoint:Point;		var UpBumpPoint:Point;		var DownBumpPoint:Point; 				var LastPos:Point;				public override function onAddedToStage(event:Event)		{			super.onAddedToStage(event);						RightBumpPoint = new Point(this.width/2, 0);			LeftBumpPoint = new Point(-this.width/2, 0);			UpBumpPoint = new Point(0, -this.height/2);			DownBumpPoint = new Point(0, this.height/2);						hook = new GrappleHook();						this.scaleX = SCALE;			this.scaleY = SCALE;						// make a container to hold the boundry drawing				var rect:Rectangle = this.getBounds(this);			var yourBoundBox:Sprite = new Sprite();							// draw a box based on the rect			with(yourBoundBox.graphics) {				lineStyle(1,0xFF0000);				moveTo(rect.x, rect.y);				lineTo(rect.x + rect.width, rect.y);				lineTo(rect.x + rect.width, rect.y+rect.height);				lineTo(rect.x, rect.y+rect.height);				lineTo(rect.x, rect.y);			}			yourBoundBox.x = this.x;			yourBoundBox.y = this.y;			addChild(yourBoundBox);		}				public override function onTick(event:Event)		{LastPos = new Point(this.x, this.y);						if (!DownBump && !isLatch)			{				velocityY += this.GRAVITY;			}						//Moving			if (Game.inputManager.isCmdPressed(InputManager.LEFT))			{				if (LeftBump && canLatch) {					if (!isCrouch) {						trace("LATCH LEFT");						this.isLatch = true;					}				} else {					this.isLatch = false;					velocityX -= SPEED;					this.scaleX = SCALE;				}			}			if (Game.inputManager.isCmdPressed(InputManager.RIGHT))			{				if (RightBump && canLatch) {					if (!isCrouch) {						trace("LATCH RIGHT");						this.isLatch = true;					}				} else {					this.isLatch = false;					velocityX += SPEED;					this.scaleX = -SCALE;				}			}			if (isLatch && (LeftBump || RightBump))			{				if (Game.inputManager.isCmdPressed(InputManager.UP) && ! UpBump && canLatch) {					Game.gameContainer.move(0, -this.SPEED / 2);				} else if (Game.inputManager.isCmdPressed(InputManager.DOWN) && ! DownBump && canLatch) {					Game.gameContainer.move(0, this.SPEED / 2);				}			}						if (Game.inputManager.justCmdPressed(InputManager.JUMP) && ! UpBump && DownBump)			{				velocityY += this.JUMP;			}			if (Game.inputManager.justCmdPressed(InputManager.DOWN) && DownBump)			{				this.isCrouch = true;			}						//Max Speed			//Scale down if too fast;			if (velocityX > this.MAXSPEED)			{ //moving right				velocityX = this.MAXSPEED;			}			else if (velocityX < (this.MAXSPEED * -1))			{ //moving left				velocityX = (this.MAXSPEED * -1);			}						//stop if low speed			if (Math.abs(velocityX) < 0.5)			{				velocityX = 0;			}			else if (Math.abs(velocityY) < 0.5)			{				velocityY = 0;			}						//Adding Friction			velocityX *= this.FRICTION;			velocityY *= this.AIRFRICTION;						//React to Bumps			if (LeftBump && velocityX < 0)			{				velocityX *=  -0.5;			}			if (RightBump && velocityX > 0)			{				velocityX *=  -0.5;			}			if (UpBump && velocityY < 0)			{				velocityY *=  -0.5;			}						if (DownBump && velocityY > -2)			{				velocityY *=  -0.5;			}						//firing Hook			if(Game.inputManager.mouseClick)			{				//make hook visible				Game.gameContainer.hook.visible = true;				Game.gameContainer.hook.x = LastPos.x;				Game.gameContainer.hook.y = LastPos.y;								hook.fireHook(Game.inputManager.mousePos);				Game.inputManager.mouseClick = false;			}//end if		}	}}